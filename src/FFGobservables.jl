""" Observables that can be measured on a gutzwiller state """

function Szi(chain::GutzwillerChain,i)
    state = get_State(chain)
    model = get_Model(chain)
    Sz = state.spin_config.sc[i]
    data = Dict("Szi" => Float64(Szi))
    return data
end

using Statistics: mean
function NeighborSzSz(chain::GutzwillerChain)
    state = get_State(chain)
    model = get_Model(chain)
    lg = model["lattice"].graph # latticegraph
    spinc = state.spin_config.sc # spin config array

    SzSz = 0

    for i in vertices(lg)
        SzSz += mean([spinc[i]*spinc[j]/4 for j in neighbors(lg,i)])
    end

    data = Dict("SzSz" => Float64(SzSz)/nv(lg))
    return data
end

mutable struct ElectronTinder
    """ Database to match lonely up spins with lonely down spins by site"""
    lonely_up::Array{Int}
    lonely_down::Array{Int}
    ElectronTinder() = new([],[])
end

function SwipeRight(database::ElectronTinder)
    """ Creates list of matches (moves) generated by
    electron tinder's database """
    @assert length(database.lonely_up) == length(database.lonely_down)
    lu = database.lonely_up
    ld = database.lonely_down
    nmatches = length(lu)
    matches = Array{Tuple}(undef,nmatches)
    for i in 1:nmatches
        matches(i) = (lu(i),ld(i))
    end
    return matches
end

# using Statistics: mean
# function Swap(chain::DoubleGutzwillerChain,regionsize::Int)
#
#     """ regionsize â‰ˆ r, the radius of the region selected """
#     state = get_State(chain)
#     lg = get_Model(chain)["lattice"].graph
#
#     swap_per_site = []
#
#     for v in vertices(lg)
#         sites = nearest_neighbors(lg,v,regionsize)
#         swap_per_site[v] = compute_swapregion(state,sites)
#     end
#
#     return mean(swap_per_site)
# end
#
#
#          (spinc1, spinc2) = (state[1].spin_configuration.sc[sites],
#           state[1].spin_configuration.sc[sites])
